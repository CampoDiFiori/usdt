use byteorder::{NativeEndian, ReadBytesExt};
use dof::{
    fmt::{fmt_dof_sec, fmt_dof_sec_data},
    serialize_section, Probe, Provider, Section,
};
use pretty_hex::PrettyHex;
use std::{collections::BTreeMap, convert::TryInto, ffi::CString, path::Path};

use crate::parser::File;
use crate::DTraceError;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
mod staticlib;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
pub use staticlib::build_providers;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
mod empty;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
pub use empty::build_providers;

#[derive(Debug, Clone, Copy)]
pub enum ExpandFormat {
    /// Expand probes to the Rust side of the FFI glue code.
    Rust,

    /// Expand probes to their corresponding C declarations.
    Declaration,

    /// Expand probes to the C side of the FFI glue code.
    Definition,
}

/// Expand the probe functions into the autogenerated FFI components.
///
/// This function returns the formatted code that comprises the Rust and C sides of the FFI used to
/// fire DTrace probes from a Rust program.
pub fn expand<P: AsRef<Path>>(source: P, format: ExpandFormat) -> Result<String, DTraceError> {
    let file = File::from_file(source.as_ref())?;
    Ok(format!(
        "{}",
        match format {
            ExpandFormat::Rust => file.to_rust_impl(),
            ExpandFormat::Declaration => file.to_c_declaration(),
            ExpandFormat::Definition => file.to_c_definition(),
        }
    ))
}

/// Register the probes that the asm mechanism dumps into a linker section.
///
/// This probably needs to live somewhere else, but I wasn't quite sure where...
pub fn register_probes() {
    println!("registering probes...");

    extern "C" {
        #[cfg_attr(
            target_os = "macos",
            link_name = "\x01section$start$__DATA$__dtrace_probes"
        )]
        #[cfg_attr(target_os = "illumos", link_name = "__start_set_dtrace_probes")]
        static dtrace_probes_start: usize;
        #[cfg_attr(
            target_os = "macos",
            link_name = "\x01section$end$__DATA$__dtrace_probes"
        )]
        #[cfg_attr(target_os = "illumos", link_name = "__stop_set_dtrace_probes")]
        static dtrace_probes_stop: usize;
    }

    let mut data = unsafe {
        let start = (&dtrace_probes_start as *const usize) as usize;
        let stop = (&dtrace_probes_stop as *const usize) as usize;

        std::slice::from_raw_parts(start as *const u8, stop - start)
    };

    let mut providers = BTreeMap::<String, Provider>::new();

    while !data.is_empty() {
        if data.len() < 4 {
            panic!("not enough bytes for length header");
        }

        let x = &data[..4];
        let len = u32::from_ne_bytes(x.try_into().unwrap());

        let (rec, rest) = data.split_at(len as usize);
        data = rest;

        println!("len {:#x}", len);

        // TODO this is where we'll pull out the probe data and pass it along to dof
        process_rec(&mut providers, rec);
    }
    let section = Section {
        providers: providers.into_iter().map(|(_, v)| v).collect(),
        ..Default::default()
    };

    send_section_to_kernel(&section);
}

// DOF-format a section and send to DTrace kernel driver, via ioctl(2) interface
fn send_section_to_kernel(section: &Section) {
    let v = serialize_section(&section);

    let (header, sections) = dof::des::deserialize_raw_sections(&v).unwrap();
    println!("{:#?}", header);
    for (index, (section_header, data)) in sections.into_iter().enumerate() {
        // TODO this is a little janky, but I wrestled a bit with bindgen before just doing it
        println!("{}", fmt_dof_sec(&section_header, index));
        if true {
            println!("{}", fmt_dof_sec_data(&section_header, &data));
            println!();
        }
    }

    let ss = Section::from_bytes(&v);
    println!("{:#?}", ss);
    ioctl_section(&v);
}

#[cfg(target_os = "macos")]
fn ioctl_section(buf: &[u8]) {
    let mut modname = [0 as ::std::os::raw::c_char; 64];
    modname[0] = 'a' as i8;
    let helper = dof::dof_bindings::dof_ioctl_data {
        dofiod_count: 1,
        dofiod_helpers: [dof::dof_bindings::dof_helper {
            dofhp_mod: modname,
            dofhp_addr: buf.as_ptr() as u64,
            dofhp_dof: buf.as_ptr() as u64,
        }],
    };
    let data = &(&helper) as *const _;
    let cmd: u64 = 0x80086804;
    let ret = unsafe {
        let file = CString::new("/dev/dtracehelper".as_bytes()).unwrap();
        let fd = libc::open(file.as_ptr(), libc::O_RDWR);
        libc::ioctl(fd, cmd, data)
    };
    println!("ioctl {} {}", ret, std::io::Error::last_os_error());
}

#[cfg(not(target_os = "macos"))]
fn ioctl_section(buf: &[u8]) {
    let mut modname = [0 as ::std::os::raw::c_char; 64];
    modname[0] = 'a' as i8;
    let helper = dof::dof_bindings::dof_helper {
        dofhp_mod: modname,
        dofhp_addr: buf.as_ptr() as u64,
        dofhp_dof: buf.as_ptr() as u64,
    };
    let data = &helper as *const _;
    let cmd: i32 = 0x64746803;
    let ret = unsafe {
        let file = CString::new("/dev/dtrace/helper".as_bytes()).unwrap();
        let fd = libc::open(file.as_ptr(), libc::O_RDWR);
        libc::ioctl(fd, cmd, data)
    };
    println!("ioctl {} {}", ret, std::io::Error::last_os_error());
}

fn process_rec(providers: &mut BTreeMap<String, Provider>, rec: &[u8]) {
    println!("{:?}", rec.hex_dump());
    let mut data = &rec[4..];

    println!("{:?}", data.hex_dump());

    let ty = data.read_u32::<NativeEndian>().unwrap();
    let address = data.read_u64::<NativeEndian>().unwrap();
    let provname = data.cstr();
    let funcname = data.cstr();
    let probename = data.cstr();

    println!("{:?}", data.hex_dump());

    println!("{:#x} {}::{}:{}", address, provname, funcname, probename);

    if ty == 1 {
        let provider = providers.entry(provname.to_string()).or_insert(Provider {
            name: provname.to_string(),
            probes: Vec::new(),
        });

        provider.probes.push(Probe {
            name: probename.to_string(),
            function: funcname.to_string(),
            address: address,
            offsets: vec![0],
            enabled_offsets: vec![],
            arguments: vec![],
        });
    }
}

trait ReadCstrExt<'a> {
    fn cstr(&mut self) -> &'a str;
}

impl<'a> ReadCstrExt<'a> for &'a [u8] {
    fn cstr(&mut self) -> &'a str {
        let index = self
            .iter()
            .position(|ch| *ch == 0)
            .expect("ran out of bytes before we found a zero");

        let ret = std::str::from_utf8(&self[..index]).unwrap();
        *self = &self[index + 1..];
        ret
    }
}
