use pretty_hex::PrettyHex;
use std::{convert::TryInto, path::Path};

use crate::parser::File;
use crate::DTraceError;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
mod staticlib;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
pub use staticlib::build_providers;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
mod empty;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
pub use empty::build_providers;

#[derive(Debug, Clone, Copy)]
pub enum ExpandFormat {
    /// Expand probes to the Rust side of the FFI glue code.
    Rust,

    /// Expand probes to their corresponding C declarations.
    Declaration,

    /// Expand probes to the C side of the FFI glue code.
    Definition,
}

/// Expand the probe functions into the autogenerated FFI components.
///
/// This function returns the formatted code that comprises the Rust and C sides of the FFI used to
/// fire DTrace probes from a Rust program.
pub fn expand<P: AsRef<Path>>(source: P, format: ExpandFormat) -> Result<String, DTraceError> {
    let file = File::from_file(source.as_ref())?;
    Ok(format!(
        "{}",
        match format {
            ExpandFormat::Rust => file.to_rust_impl(),
            ExpandFormat::Declaration => file.to_c_declaration(),
            ExpandFormat::Definition => file.to_c_definition(),
        }
    ))
}

/// Register the probes that the asm mechanism dumps into a linker section.
///
/// This probably needs to live somewhere else, but I wasn't quite sure where...
pub fn register_probes() {
    println!("registering probes...");

    extern "C" {
        #[cfg_attr(
            target_os = "macos",
            link_name = "\x01section$start$__DATA$__dtrace_probes"
        )]
        #[cfg_attr(target_os = "illumos", link_name = "__start_set_dtrace_probes")]
        static dtrace_probes_start: usize;
        #[cfg_attr(
            target_os = "macos",
            link_name = "\x01section$end$__DATA$__dtrace_probes"
        )]
        #[cfg_attr(target_os = "illumos", link_name = "__stop_set_dtrace_probes")]
        static dtrace_probes_stop: usize;
    }

    let mut data = unsafe {
        let start = (&dtrace_probes_start as *const usize) as usize;
        let stop = (&dtrace_probes_stop as *const usize) as usize;

        std::slice::from_raw_parts(start as *const u8, stop - start)
    };

    while !data.is_empty() {
        if data.len() < 4 {
            panic!("not enough bytes for length header");
        }

        let x = &data[0..4];
        let len = u32::from_ne_bytes(x.try_into().unwrap());

        let (rec, rest) = data.split_at(len as usize);
        data = rest;

        println!("len {:#x}", len);
        println!("{:?}", rec.hex_dump());

        // TODO this is where we'll pull out the probe data and pass it along to dof
    }
}
