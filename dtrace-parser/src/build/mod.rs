use std::path::Path;

use crate::DTraceError;
use crate::parser::File;

#[cfg(any(
    target_os = "macos",
    target_os = "illumos",
    target_os = "freebsd",
    target_os = "dragonfly",
    target_os = "openbsd",
    target_os = "netbsd"
))]
mod build;

#[cfg(any(
    target_os = "macos",
    target_os = "illumos",
    target_os = "freebsd",
    target_os = "dragonfly",
    target_os = "openbsd",
    target_os = "netbsd"
))]
pub use build::build_providers;

#[cfg(not(any(
    target_os = "macos",
    target_os = "illumos",
    target_os = "freebsd",
    target_os = "dragonfly",
    target_os = "openbsd",
    target_os = "netbsd"
)))]
mod empty;

#[cfg(not(any(
    target_os = "macos",
    target_os = "illumos",
    target_os = "freebsd",
    target_os = "dragonfly",
    target_os = "openbsd",
    target_os = "netbsd"
)))]
pub use empty::build_providers;

#[derive(Debug, Clone, Copy)]
pub enum ExpandFormat {
    /// Expand probes to the Rust side of the FFI glue code.
    Rust,

    /// Expand probes to their corresponding C declarations.
    Declaration,

    /// Expand probes to the C side of the FFI glue code.
    Definition,
}

/// Expand the probe functions into the autogenerated FFI components.
///
/// This function returns the formatted code that comprises the Rust and C sides of the FFI used to
/// fire DTrace probes from a Rust program.
pub fn expand<P: AsRef<Path>>(source: P, format: ExpandFormat) -> Result<String, DTraceError> {
    let file = File::from_file(source.as_ref())?;
    Ok(format!(
        "{}",
        match format {
            ExpandFormat::Rust => file.to_rust_impl(),
            ExpandFormat::Declaration => file.to_c_declaration(),
            ExpandFormat::Definition => file.to_c_definition(),
        }
    ))
}
