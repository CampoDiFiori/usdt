use std::path::Path;

use crate::parser::File;
use crate::DTraceError;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
mod staticlib;

#[cfg(all(
    any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    ),
    not(feature = "asm"),
))]
pub use staticlib::build_providers;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
mod empty;

#[cfg(any(
    not(any(
        target_os = "macos",
        target_os = "illumos",
        target_os = "freebsd",
        target_os = "dragonfly",
        target_os = "openbsd",
        target_os = "netbsd"
    )),
    feature = "asm"
))]
pub use empty::build_providers;

#[derive(Debug, Clone, Copy)]
pub enum ExpandFormat {
    /// Expand probes to the Rust side of the FFI glue code.
    Rust,

    /// Expand probes to their corresponding C declarations.
    Declaration,

    /// Expand probes to the C side of the FFI glue code.
    Definition,
}

/// Expand the probe functions into the autogenerated FFI components.
///
/// This function returns the formatted code that comprises the Rust and C sides of the FFI used to
/// fire DTrace probes from a Rust program.
pub fn expand<P: AsRef<Path>>(source: P, format: ExpandFormat) -> Result<String, DTraceError> {
    let file = File::from_file(source.as_ref())?;
    Ok(format!(
        "{}",
        match format {
            ExpandFormat::Rust => file.to_rust_impl(),
            ExpandFormat::Declaration => file.to_c_declaration(),
            ExpandFormat::Definition => file.to_c_definition(),
        }
    ))
}
